# user-auth

## Purpose

用户认证能力：用户名+密码注册与登录、JWT 签发与校验、Hono JWT 中间件保护受保护路由。

## ADDED Requirements

### Requirement: User model in Prisma schema
The backend SHALL define a User model in the Prisma schema with: `id` (BigInt, primary key, generated by Snowflake), `username` (unique, non-empty), `passwordHash` (non-empty), `create_time` (DateTime, default now()), `update_time` (DateTime, updatedAt). The backend MUST NOT store plain-text passwords. The User table MAY be mapped to table name `user` via `@@map("user")`.

#### Scenario: User model fields
- **WHEN** the Prisma schema is inspected
- **THEN** the User model has `id` as BigInt primary key, `username` with `@unique`, `passwordHash`, `create_time`, and `update_time` as DateTime

#### Scenario: Password not stored in plain text
- **WHEN** a user registers or updates password
- **THEN** only a hash of the password (e.g. bcrypt) is stored in `passwordHash`

### Requirement: Register API
The backend SHALL expose `POST /api/auth/register` that accepts `username` and `password` in the request body (both required, non-empty). The backend MUST validate the body (e.g. with Zod) and return 400 when validation fails. The backend MUST create a new user when the username is not taken, hash the password before storing (e.g. bcrypt), and return a success response with unified format `{ code: 200, msg: "success", data: { username } }`. The backend MUST return 409 when the username already exists (e.g. `{ code: 409, msg: "username already exists" }`).

#### Scenario: Successful registration
- **WHEN** a client sends `POST /api/auth/register` with a unique username and password
- **THEN** the backend creates a user, stores the hashed password, and returns 200 with `data.username` equal to the registered username

#### Scenario: Registration with duplicate username
- **WHEN** a client sends `POST /api/auth/register` with a username that already exists
- **THEN** the backend returns 409 and does not create a user

#### Scenario: Registration with invalid body
- **WHEN** a client sends `POST /api/auth/register` with missing or empty username or password
- **THEN** the backend returns 400 (e.g. "username and password are required")

### Requirement: Login API
The backend SHALL expose `POST /api/auth/login` that accepts `username` and `password` in the request body. The backend MUST verify the password against the stored hash and, on success, return a JWT token in the response body in unified format with `data: { token: "<jwt>" }`. The backend MUST return 401 when credentials are invalid (e.g. wrong username or password), with a single error message such as "invalid username or password" so as not to reveal whether the username exists.

#### Scenario: Successful login
- **WHEN** a client sends `POST /api/auth/login` with valid username and password
- **THEN** the backend returns 200 with `data.token` containing the JWT

#### Scenario: Login with invalid credentials
- **WHEN** a client sends `POST /api/auth/login` with wrong username or password
- **THEN** the backend returns 401 and does not return a token

### Requirement: JWT signing and verification
The backend SHALL sign JWTs with a secret read from the environment (`JWT_SECRET`). The JWT payload SHALL include `sub` (user id as string) and `username`. The backend SHALL support token expiration via `JWT_EXPIRES_IN` (e.g. default `"7d"`). The backend SHALL verify JWTs using the same secret when protecting routes. Implementation MAY use the `jose` library with algorithm HS256.

#### Scenario: JWT contains user identity
- **WHEN** a client receives a JWT after successful login
- **THEN** decoding the JWT (without verification) shows payload fields `sub` (user id) and `username`

#### Scenario: Expired or invalid token rejected
- **WHEN** a request carries an expired or invalid JWT to a protected route
- **THEN** the backend responds with 401 and does not expose the protected resource

### Requirement: Hono JWT middleware
The backend SHALL provide a Hono middleware (e.g. `jwtAuth`) that: reads the `Authorization: Bearer <token>` header, verifies the JWT, and on success sets the user information `{ id: string, username: string }` on the Hono context (e.g. `c.set("user", ...)`) so that handlers can access it via `c.get("user")`. On verification failure (missing token, invalid or expired token), the middleware MUST respond with 401 and the unified API response format (e.g. `{ code: 401, msg: "Unauthorized", data: {} }`).

#### Scenario: Valid Bearer token sets user on context
- **WHEN** a request to a route protected by the JWT middleware includes a valid `Authorization: Bearer <token>` header
- **THEN** the middleware sets `user` on the context with `id` and `username`, and the handler can access it via `c.get("user")`

#### Scenario: Missing or invalid token returns 401
- **WHEN** a request to a route protected by the JWT middleware has no Authorization header, or an invalid or expired token
- **THEN** the middleware responds with HTTP 401 and a response body in the unified format (e.g. code 401, msg "Unauthorized")

### Requirement: Auth configuration in environment
The backend SHALL read `JWT_SECRET` and optional `JWT_EXPIRES_IN` from the environment for signing and verifying JWTs. The backend SHALL document `JWT_SECRET` and `JWT_EXPIRES_IN` in `apps/backend/.env.example` with example values or placeholders.

#### Scenario: JWT secret from environment
- **WHEN** the backend signs or verifies a JWT
- **THEN** it uses `JWT_SECRET` from the process environment; expiration uses `JWT_EXPIRES_IN` if set (e.g. default `"7d"`)

#### Scenario: Example env documented
- **WHEN** a developer reads `apps/backend/.env.example`
- **THEN** they see entries for `JWT_SECRET` and `JWT_EXPIRES_IN` (e.g. `JWT_SECRET=your-secret-key`, `JWT_EXPIRES_IN=7d`)

### Requirement: Example protected route (optional)
The backend MAY expose an example protected route (e.g. `GET /api/me`) that uses the JWT middleware and returns the current user (e.g. `{ id, username }`) from `c.get("user")`, to demonstrate usage of the middleware.
